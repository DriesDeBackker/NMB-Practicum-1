\documentclass[a4paper]{article}
\usepackage[dutch]{babel}
\usepackage{amsmath}
\usepackage{graphicx}

\title{Practicum NMB : Eigenwaardenproblemen}
\author{Mijn Naam}
\date{vrijdag 25 april 2014}

\newcommand{\opgave}[1]{\section*{Opgave #1}}
\newcommand{\dx}{\Delta x}
\newcommand{\dy}{\Delta y}
\newcommand{\dz}{\Delta z}
\newcommand{\dt}{\Delta t}

\usepackage{lipsum}
\usepackage{subcaption}
\usepackage{amsfonts}
\usepackage{mathtools}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\begin{document}
\maketitle


\opgave{1}

Zij $P \in \mathbb{R}^{n \times n} $ en $x \in \mathbb{R}^{n}$, dan $Px = \frac{x + Fx}{2}$ met $F \in \mathbb{R}^{n \times n}$ de matrix die de elementen $x_1$ en $x_2$, $x_3$ en $x_4$, ... omwisselt bij de vermenigvuldiging $Fx.$
Dan:

\begin{equation}
	Px = \frac{1}{2}(I + F)x \Leftrightarrow P = \frac{1}{2}(I+F)
\end{equation}
	
* $P$ is een projector indien $P$ vierkant(gegeven) en $P$ idempotent ($P^2 = P$).
We hebben:

\begin{equation}
	P^2 = \frac{1}{4}(I^2 + 2F + F^2)
\end{equation}

Aangezien $F$ het eerste en tweede element, het derde en vierde element enz... van een vector omwisselt, doet een tweede vermenigvuldiging met $F$ deze permutatie terug teniet. 
Dus: $F^2 = I$ . Dan:

\begin{equation}
	P^2 = \frac{1}{4}(I + 2F + I) = \frac{1}{4}(2I + 2F) = \frac{1}{2}(I + F) = P
\end{equation}

* $P$ is een orthogonale projector $\Leftrightarrow P = P^{*}$.
We hebben:

\begin{equation}
	P^* = \frac{1}{2}(I + F)^* = \frac{1}{2}(I^* + F^*)
\end{equation}

We kunnen nagaan dat:

\begin{equation}
	F = \begin{bmatrix}
		0 & 1 &  \\
  		1 & 0 &  \\
  		  &   & 0 & 1\\
  		  &   & 1 & 0\\
  		  &   &   &  & \ddots &  \\
  		  &   &   &  & 	 & 0 & 1 \\
  		  &   &   &  &   & 1 & 0 \\
		\end{bmatrix}  = F^*
\end{equation}
zodat:
\begin{equation}
	P^* = \frac{1}{2}(I^* + F^*) = \frac{1}{2}(I + F) = P
\end{equation}
waaruit volgt dat P een orthogonale projector is.

\pagebreak

\opgave{2}

Een Householder transformatiematrix heeft de volgende structuur:

\begin{equation}
		Q_k = \begin{bmatrix}
		I &  \\
  		  & F   \\
		\end{bmatrix} 
\end{equation}
met $I$ de $(k-1) \times (k-1)$ eenheidsmatrix en $F$ een $(m-k+1) \times (m-k+1)$ unitaire Householder reflector.
Deze structuur impliceert een karakteristieke veelterm van de vorm:
\begin{equation}
		det(\lambda I - Q_k) = (\lambda-1)^k \cdot det(\lambda I-F)
\end{equation}
Voor $k \geq 1$ hebben we dus steeds eigenwaarde 1 in het spectrum van $Q_k$ met algebraïsche multipliciteit $k$. 
Aangezien dit rechtstreeks voortkomt uit het diagonaal zijn van $\begin{bmatrix} I & 0\\ \end{bmatrix}^T$, is $k$ eveneens de geometrische multipliciteit. 
Een diagonale matrix is immers nooit defectief.
We kunnen dan $k$ lineair onafhankelijke eigenvectoren vinden voor $\lambda = 1$.
Dit is gemakkelijk te verifiëren.
Neem gewoon:
\begin{equation}
	v_1 = \begin{bmatrix}
		   1  \\
  		   0  \\
  		   0  \\
  		   \vdots  \\
  		   0  \\
		  \end{bmatrix}, \quad
  	v_2 = \begin{bmatrix}
		   0  \\
  		   1  \\
  		   0  \\
  		   \vdots  \\
  		   0  \\
		  \end{bmatrix}, \quad
	v_3 = \begin{bmatrix}
		   0  \\
  		   0  \\
  		   1  \\
  		   \vdots  \\
  		   0  \\
		  \end{bmatrix}, \quad  \dots \quad
	v_k = \dots
\end{equation}
Dan $Q_k v_j = v_j \quad(\forall j \leq k)$.
Deze vectoren spannen de ruimte $\mathbb{R}^k$ op waartoe alle vectoren
van de eerste $k$ rijen van een matrix $A \in \mathbb{R}^{m \times n}$ behoren (aangevuld tot dimensie $m$ met nulle. 
Vermits elke kolomvector van A tot en met rij k (en vervolgens aangevuld met nullen tot dimensie m) een lineaire combinatie is van bovenstaande $v_j$ zal een vermenigvuldiging met $Q_k$ neerkomen op een vermenigvuldiging met $\lambda = 1$. Householder laat dus de eerste $k$ rijen van de matrix $A$ ongemoeid zoals men hoopt te verwachten van een Householder transformatiematrix.\\
\\
De Householder reflector $F$ zal dan zorgen voor de nodige nullen zonder voorheen aangebrachte nullen te vernietigen.

\pagebreak

\opgave{3}

a) De functies Householder\_explicit, Householder\_implicit en Apply\_Q zijn bijgevoegd als MATLAB-bestanden. \\
\\
b) Indien we een willekeurig stelsel oplossen met Householder\_explicit en we variëren de dimensie n en het conditiegetal $\kappa$, verkrijgen we de resultaten uit Tabel 1. Hetzelfde kunnen we doen voor Householder\_implicit gebruik makend van Apply\_Q, wat de resultaten uit Tabel 2 oplevert.\\
\\
Het lijkt erop dat het conditiegetal weinig invloed heeft op de rekentijd. De afmetingen van het matrixprobleem daarentegen wel. $Ax = b$ oplossen m.b.v. Householder\_explicit lijkt een zeer slecht idee te zijn bij matrices van een groter formaat. Householder\_implicit in combinatie met Apply\_Q heeft hier dan weer geen problemen mee.

\begin{table}
\begin{center}
\begin{tabular}{r|llc}
$\kappa$ \textbackslash{} n & 10 & 100 & 1000 \\\hline
1 & 0.0034s & 0.0402s & 71.6416s \\
$10^4$ & 0.0026s & 0.0342s & 66.5048s \\
$10^8$ & 0.0126s & 0.0312s & 66.1448s
\end{tabular}
\end{center}
\caption{Householder\_explicit}
\label{tab1}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{r|llc}
$\kappa$ \textbackslash{} n & 10 & 100 & 1000 \\\hline
1 & 0.0044 & 0.0194s & 0.0601s \\
$10^4$ & 0.0027s & 0.0188s & 0.0758s \\
$10^8$ & 0.0154s & 0.0137s & 0.0590s
\end{tabular}
\end{center}
\caption{Householder\_implicit & Apply\_Q}
\label{tab1}
\end{table}

\opgave{4}

\opgave{5}

\opgave{6}

\opgave{7}

\opgave{8}


\opgave{9}
Het is mogelijk om Jacobi rotaties in parallel uit te voeren door ze op disjuncte rij-/kolomparen.
te laten inwerken. Zij $A$ een symmetrische matrix, dan kunnen we dit parallelisme voorstellen door twee rotaties in een enkele rotatiematrix te steken.

\pagebreak

\opgave{10}

Het volgende algoritme in pseudocode brengt nullen aan op achtereenvolgens (1,2), (1,3), ... , (1,n); (2,3), (2,4), ... , (2,n); ... ; (n-2,n-1), (n-2,n) ; (n-1,n) en op alle elementen hiermee symmetrisch t.o.v. de hoofddiagonaal.\\

$Jacobi(A,\, tolerance)$ \{\\
\\
\tab $n = width(A)$;\\
\tab $J = I(n,n)$;\\
\tab $imprecision = 100$;\\
\\
\tab $while\, (tolerance < imprecision)$ \{\\
\tab \tab $for\, (i = 1;\, i = n-1;\, i$++$)$ \{\\
\tab \tab \tab $for\, (j = i+1;\, j = m;\, j$++$)$ \{\\
\tab \tab \tab \tab $a = A(i,i)$;\\
\tab \tab \tab \tab $b = A(i,j)$;\\
\tab \tab \tab \tab $\theta = (1/2) \cdot atan(2d/(b-a))$;\\
\tab \tab \tab \tab $s = sin(\theta)$;\\
\tab \tab \tab \tab $c = cos(\theta)$;\\
\tab \tab \tab \tab $J_k = I(n,n)$;\\
\tab \tab \tab \tab $J_k(i,i) = c$;\\
\tab \tab \tab \tab $J_k(j,j) = c$;\\
\tab \tab \tab \tab $J_k(i,j) = s$;\\
\tab \tab \tab \tab $J_k(j,i) = -s$\\
\tab \tab \tab \tab $J = J \cdot J_k$;\\
\tab \tab \tab \tab $A = (J_k)^T \cdot A \cdot J_k$;\\
\tab \tab \tab \}\\
\tab \tab \}\\
\tab \tab \\
\tab \tab $offdiagnorm = (sumofsquares(A) - sumofdiagonalsquares(A))^{1/2}$;\\
\tab \tab $imprecision = |offdiagsum/maxdiagonal(A)|$;\\
\tab \}\\
\tab \\
\tab $D = A$;\\
\tab $V = J$;\\
\tab $return\ V,\,D$;\\

De implementatie in MATLAB volgt bovenstaande structuur en is te vinden in het bijgeleverde bestand 'jacobi.m'.

\pagebreak

\opgave{11}

De cursus geeft aan dat de de convergentie van een symmetrische matrix met dimensie $m\leq 1000$ typisch gebeur t in minder dan tien sweeps. Dit lijkt te kloppen. De bijgevoegde matrix mat1 convergeert in 8 sweeps. De norm van de niet-diagonaalelementen, gedeeld door het grootste diagonaalelement, wordt dan immers volledig nul in MATLAB (m.a.w. de fout is van $O(\epsilon_{mach})$).\\
\\
Voor een willekeurige symmetrische tridiagonale matrix is de rekenkost van dit algoritme dezelfde als van een willekeurige symmetrische niet-tridiagonale matrix, aangezien het algoritme met de structuur van de matrix, afgezien van de noodzakelijk symmetrie, geen rekening houdt. Indien we een variant zouden maken, enkel voor tridiagonale matrices, gebeurt een sweep in m-1 iteraties, nl. het aantal elementen op de diagonaal juist boven of onder de hoofddiagonaal. De rekenkost is dan $O(m)$.


\end{document}
